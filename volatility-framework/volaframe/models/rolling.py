"""Rolling-window variance baseline volatility model."""

from __future__ import annotations

from typing import Sequence

import numpy as np

from .base import BaseVolatilityModel


class RollingVarianceModel(BaseVolatilityModel):
    """Rolling-variance volatility forecasting model.

    This model estimates volatility using a fixed-size rolling window over
    historical returns. Let :math:`r_t` denote the return at time
    :math:`t` and ``window`` the number of observations in the window.
    The rolling variance at time :math:`t` is computed as the average of
    squared returns in the window:

    .. math::

        \\sigma_t^2 = \\frac{1}{W} \\sum_{j = 0}^{W-1} r_{t-j}^2,

    where :math:`W` is the window length. The model stores and reports
    volatility as :math:`\\sigma_t = \\sqrt{\\sigma_t^2}`.

    Forecasts are generated by assuming a flat volatility term structure,
    so each of the next ``h`` periods shares the same forecast equal to
    the last fitted volatility.
    """

    def __init__(self, window: int = 21) -> None:
        """Create a new rolling-variance volatility model.

        Parameters
        ----------
        window:
            Rolling window length (number of observations). Must be a
            positive integer.
        """
        if window <= 0:
            raise ValueError("window must be a positive integer.")

        self.window = int(window)
        super().__init__(name="RollingVariance", params={"window": self.window})

        # Array of fitted volatilities (standard deviations).
        self.volatility_: np.ndarray | None = None

    def fit(self, returns: Sequence[float]) -> "RollingVarianceModel":
        """Fit the rolling-variance model to a sequence of returns.

        Parameters
        ----------
        returns:
            One-dimensional array-like of returns (e.g. log-returns).

        Returns
        -------
        RollingVarianceModel
            The fitted model instance.

        Notes
        -----
        The rolling variance is computed as the mean of squared returns
        over a fixed window. For the first ``window - 1`` observations
        where a full window is not available, the variance is set to
        ``nan``; the last fitted volatility always corresponds to a full
        window.
        """
        r = np.asarray(returns, dtype=float).ravel()
        if r.size == 0:
            raise ValueError("returns must contain at least one observation.")
        if r.size < self.window:
            raise ValueError(
                f"returns length ({r.size}) must be at least as large as "
                f"the window size ({self.window})."
            )

        w = self.window
        squared = r**2

        # Rolling mean of squared returns using convolution.
        kernel = np.ones(w, dtype=float) / float(w)
        rolling_var_valid = np.convolve(squared, kernel, mode="valid")

        # Expand to full length by padding the initial positions with NaN.
        var = np.empty_like(r, dtype=float)
        var[: w - 1] = np.nan
        var[w - 1 :] = rolling_var_valid

        self.volatility_ = np.sqrt(var)
        return self

    def predict(self, h: int = 1) -> np.ndarray:
        """Forecast future volatility over a given horizon.

        Forecasts are flat across the horizon: each of the next ``h``
        periods receives the same forecast equal to the last fitted
        volatility.

        Parameters
        ----------
        h:
            Forecast horizon (number of periods to predict). Must be a
            positive integer.

        Returns
        -------
        numpy.ndarray
            Array of length ``h`` with the volatility forecast for each
            future period.

        Raises
        ------
        ValueError
            If ``h`` is not a positive integer or if the model has not
            been fitted prior to calling this method.
        """
        if h <= 0:
            raise ValueError("h must be a positive integer.")

        if self.volatility_ is None or self.volatility_.size == 0:
            raise ValueError("Model must be fitted before calling predict().")

        # The last value is always based on a full window.
        last_vol = float(self.volatility_[-1])
        return np.full(shape=int(h), fill_value=last_vol, dtype=float)

